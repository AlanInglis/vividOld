---
title: "Variable Importance and Variable Interaction Displays (vivid)"
author: "Alan Inglis, Catherine Hurley, Andrew Parnell"
output: 
  bookdown::pdf_document2:
    fig_caption: true 
    toc : true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = 'pdf',cache = FALSE,
                      fig.align = 'center', 
                      fig.pos="H",
                      out.extra = '')
par(mar=c(3,3,2,1), mgp=c(2,.7,0), tck=-.01,las=1)
```

\section{Details:}
__Type__ Package

__Title__ vivid

__Version__ 0.1.0

__Description__ A package for displaying variable importance and two-way variable interaction on the same plot. Partial dependence plots are also available in this package.

__Licence__ GPL (>=2)

__Depends__

__Imports__

__Authors__ Alan n. Inglis, Catherine Hurley, Anderw Parnell

\section{Introduction:}
This package was designed to help a user to easily distiguish which variables in a model are important and which variables interact with each other. It does this by giving the user different plotting options. These include a heatmap style plot that displays 2-way interactions and individual variable importance. Also, a network style plot where the size of a node represents variable importance (the bigger the node, the more important the variable) and the edge weight represents the 2-way interaction strength. Also included is an option to dosplay partial dependence plots that utilize an Eularian tour to help the user to easily identify which variables interact the most.


```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(mlr)
library(reshape2)
library(ggplot2)
library(iml)
library(tidyr)
library(igraph)
library(plotly)
library(ggnewscale)
library(RColorBrewer)
```



\newpage()
\section{Commands:}

## intHeatmap
__________________________________________________________________________________________________
intHeatmap()   *Create a Heatmap style plot displaying Variable Importance and Variable Interaction*
__________________________________________________________________________________________________
__Description__

Plots a heatmap of the interaction strength with variable importance on the off-diagonal

__Usage__

intHeatmap(task, model, method, interact)

__Arguments__

task - Task created from the _mlr_ package (either regression or classification).

model - Any machine learning model.

method - A list of variable importance methods to be set by the user. The default is method = randomForest.

 * Method = randomForest : will return variable importance values from the randomForest package. 
 
 * Method = ranger Permutation : will return variable importance values from the ranger package.
 
 * Method = rfSRC : will return variable importance values from the randomForestSRC package.
 
interact - If interact = TRUE, an interactive plotly object is displayed.
 


__Examples__
```{r}
## Iris data for classification
ir <- data.frame(iris)
ir <- na.omit(ir)

## Create model using mlr package:
irClasTask  <- makeClassifTask(data = ir, target = "Species")
ir.clas.lrn <- makeLearner("classif.randomForest", predict.type = 'prob')
irMod <- train(ir.clas.lrn, irClasTask)
```

```{r, echo=FALSE}
## Heatmap Plotting Function -------------------------------------------------------

intHeatmap <- function(task, model, method = "randomForest",
                       interact = FALSE,...){
  # get data:
  data <- getTaskData(task)
  # Get Importance Measures -------------------------------------------------
  
  norm.task <- normalizeFeatures(task, method = "standardize")
  if(method == "randomForest"){
    impMethod = c("randomForest_importance")}
  else if(method == "ranger"){
    impMethod = c("ranger_permutation")}
  else if(method == "rfSRC"){
    impMethod = c("randomForestSRC_importance")
  }
  else if(method >=4)
    (return("Invalid method chosen. See ?intHeatmap for allowed methods"))
  
  im_feat <- generateFilterValuesData(norm.task, method = impMethod)
  Y_Imp <- im_feat$data$value



  mod  <- Predictor$new(model, data)
  res  <- NULL
  ovars <- getTaskFeatureNames(task)
  for (i in 1:length(ovars))
    res <- rbind(res, Interaction$new(mod, feature=ovars[i])$results)
  
  res[[".feature"]] <- reorder(res[[".feature"]], res[[".interaction"]])
  
  vars2 <- t(simplify2array(strsplit(as.character(res[[".feature"]]),":"))) # split/get feature names 
  dinteraction <- matrix(0, length(ovars), length(ovars))                   # create matrix
  rownames(dinteraction) <- colnames(dinteraction) <- ovars                 # set names
  dinteraction[vars2] <- res[[".interaction"]]                              # set values   
  dinteraction <- (dinteraction+t(dinteraction))/2                          # avg over values to make symmetrical
  diag(dinteraction) <- Y_Imp
  
  nam <- getTaskFeatureNames(task)
# Now create a plot -------------------------------------------------------

  var_int2 = dinteraction %>% as_tibble %>% 
    mutate(var_num1 = 1:length(nam)) %>% 
    pivot_longer(cols = 1:length(nam),
                 values_to = 'Interaction\nStrength') %>% 
    mutate(var_num2 = rep(1:length(nam), length(nam)),
           alpha_imp = as.integer(var_num1 == var_num2),
           alpha_int = 1 - alpha_imp,
           `Variable\nImportance` = alpha_imp*`Interaction\nStrength`,
           `Interaction\nStrength` = alpha_int*`Interaction\nStrength`)

  
  

  # for plotly  -------------------------------------------------------------
  dinteraction1 <- data.frame(interaction=as.vector(dinteraction))          # Create df
  
  dinteraction1$x <- as.vector(row(dinteraction))
  dinteraction1$y <- as.vector(col(dinteraction))
  dinteraction1$varx <- ovars[dinteraction1$x]
  dinteraction1$vary <- ovars[dinteraction1$y]
  dinteraction1$varx <- factor(dinteraction1$varx, levels=ovars)
  dinteraction1$vary <- factor(dinteraction1$vary, levels=rev(ovars))      
  
  # Importance point size:
  if(length(Y_Imp) <= 5)
  {pointSize = 15
  } else if(length(Y_Imp) <= 10)
  {pointSize = 10
  }else if(length(Y_Imp <= 15))
  {pointSize = 7}
  
  ## label titles:
  if(method == "randomForest"){
    labTitle = "randomForest \n\ Importance"
  } 
  else if(method == "ranger"){
    labTitle = "Ranger Permutation \n\ Importance"
  }
  else if(method == "rfSRC"){
    labTitle = "randomForestSRC \n\ Importance"
  }

  impMat <- matrix(0,nrow=length(Y_Imp), ncol=length(Y_Imp))
  diag(impMat) <- Y_Imp
  importMatrix <- melt(impMat)
  
  p <- ggplot(data = var_int2, 
         mapping = aes(x = var_num1, y = var_num2)) + 
    scale_x_continuous(breaks = 1:length(nam), labels = nam, position = "top") + 
    scale_y_continuous(breaks = 1:length(nam), labels = nam) +
    geom_raster(aes(fill = `Interaction\nStrength`),
                alpha = var_int2$alpha_int) + 
    new_scale_fill() +
    geom_raster(aes(fill = `Variable\nImportance`),
                alpha = var_int2$alpha_imp) + 
    scale_fill_gradient(low = "red4",high = "red") +
    ggtitle(labTitle) +
    xlab('') + 
    ylab('') + 
    theme_light() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
  # This plot is only called for plotly
  Importance <- Y_Imp
  pp <- ggplot(data=dinteraction1, aes(x=varx,y=vary)) + 
    geom_tile(aes(fill = interaction), dinteraction1 %>% filter(dinteraction1$varx != dinteraction1$vary)) +
    geom_point(aes(x=Var1,y= rev(Var2),colour = Importance),size = pointSize, importMatrix %>% filter(importMatrix$Var1==importMatrix$Var2)) +
    scale_colour_gradient(low="red4", high="red") +
    labs(colour= labTitle) +
    labs(fill='Interaction \n\ Strength') +
    theme(axis.title.x=element_blank(),axis.title.y=element_blank()) +
    scale_x_discrete(position = "top") + theme_bw()+
    xlab("")+ylab("")
  
  # Interactive plot using plotly
  ppp <- ggplotly(pp, tooltip = "all")

  if(interact == TRUE){
    return(ppp)
  }else{return(p)}
}
```

```{r}
# Plot Heatmap
intHeatmap(irClasTask, irMod, method = "randomForest", interact = F)
```
<center>
Fig 1.0: *Heatmap style plot*
</center>


## importanceNet:

__________________________________________________________________________________________________
importanceNet()   *Create a Network style plot displaying Variable Importance and Variable Interaction*
__________________________________________________________________________________________________

__Description__

Plots a network style graph, where node size and colour represent variable importance and edge width represents interaction strength.

__Usage__

Graph_fn(task, model, method, Threshold, Cluster)

__Arguments__

task - Task created from the _mlr_ package (either regression or classification).

model - Any machine learning model.

method - A list of variable importance methods to be set by the user. The default is method = 1.

 * Method = 1 will return variable importance values from the randomForest package. 
 
 * Method = 2 will return variable importance values from the ranger package.
 
 * Method = 3 will return variable importance values from the randomForestSRC package.
 
Threhold - If Threshold = TRUE then only the strongest interactions are displayed. 

Cluster - If Cluster = TRUE then the data is clustered according to interactions.  


__Examples__


```{r, echo=FALSE}
importanceNet <- function(task, model, method = "randomForest", 
                          Threshold = FALSE, Cluster = FALSE, edge.label = FALSE,...){
  # get data:
  data <- getTaskData(task)
  
  # Get importance:
  
  norm.task <- normalizeFeatures(task, method = "standardize")
  if(method == "randomForest"){
    impMethod = c("randomForest_importance")}
  else if(method == "ranger Permutation"){
    impMethod = c("ranger_permutation")}
  else if(method == "rfSRC Importance"){
    impMethod = c("randomForestSRC_importance")
  }
  else if(method >=4)
    (return("Invalid method chosen. Use ?intHeatmap for allowed methods"))
  im_feat <- generateFilterValuesData(norm.task, method = impMethod)
  Imp <- im_feat$data$value
  Imp <- (50-10)*(Imp-min(Imp))/(max(Imp)-min(Imp))+10  # Scale the Importance between 10-50 
  
  Mod <- Predictor$new(model, data = data) # iml Interaction Strength
  
  # Get names and interaction strength:
  res <- NULL
  ovars <- getTaskFeatureNames(task)
  for (i in 1:length(ovars))
    res <- rbind(res, Interaction$new(Mod, feature=ovars[i])$results)
  
  res[[".feature"]]<- reorder(res[[".feature"]], res[[".interaction"]])
  
  vars2 <- t(simplify2array(strsplit(as.character(res[[".feature"]]),":"))) # split/get feature names 
  dinteraction <- matrix(0, length(ovars), length(ovars))                   # create matrix
  rownames(dinteraction) <- colnames(dinteraction) <- ovars                 # set names
  dinteraction[vars2] <- res[[".interaction"]]                              # set values   
  dinteraction <- (dinteraction+t(dinteraction))/2                          # avg over values to make symmetrical
  
  dinteraction1 <- data.frame(interaction=as.vector(dinteraction))   
  
  # setting var names:
  INT <- dinteraction1
  UINT <- unique(INT)
  UINT <- UINT[-1,]
  IMP <-  Imp
  nam <- getTaskFeatureNames(task)
  
  # Set path direction of graph:
  g <- sample_pa(length(nam), m = length(nam))
  df <- igraph::as_data_frame(g)
  gDF <- dplyr::arrange(df, to)
  gDFL <- rbind(gDF$from,gDF$to)
  gdf <- c(gDFL)
  
  # Graph Parameters:
  net.bg <- make_graph(gdf, length(nam))
  V(net.bg)$size <- IMP
  V(net.bg)$frame.color <- "black"
  V(net.bg)[IMP < IMP+1]$color <- "#A6CEE3"#light blue
  V(net.bg)[IMP < 40]$color <- "#1F78B4"#dark blue
  V(net.bg)[IMP < 30]$color <- "#B2DF8A"#light green
  V(net.bg)[IMP < 20]$color <- "#33A02C"#dark green
  V(net.bg)[IMP < 10]$color <- "#FB9A99"# pink
  V(net.bg)$label <- nam
  V(net.bg)$label.cex <- 1.3
  V(net.bg)$label.color <- "black"
  E(net.bg)$arrow.mode <- 0
  E(net.bg)$label <- round(UINT, 3)
  E(net.bg)$width <- UINT*100
  
  l <- layout_in_circle(net.bg)
  
  #Colour legend 
  pal <- brewer.pal(12,"Paired")
  Group <- gl(5, 2, labels = c("40-50","30-40","20-30","10-20", "0-10"))
  
  # Add option to display edge label (i.e., interaction strength)
  if(edge.label == TRUE){
    E(net.bg)$label.cex <- 1
  }else{E(net.bg)$label.cex <- 0.001}
  
  
  ## Ajusting edge label text position
  # Start with the centers of the edges (on line)
  ELx = rep(0, ecount(net.bg))
  ELy = rep(0, ecount(net.bg))
  for(i in 1:ecount(net.bg)) {
    ELx[i] = (l[ends(net.bg,i)[1],1] + l[ends(net.bg,i)[2],1])/2
    ELy[i] = (l[ends(net.bg,i)[1],2] + l[ends(net.bg,i)[2],2])/2 }
  
  ## Adjust perpendicular to line
  d = 0.05
  for(i in 1:ecount(net.bg)) {
    if(abs(l[ends(net.bg,i)[1],2] - l[ends(net.bg,i)[2],2]) < 0.1) {
      ## This avoids problems with horizontal edges
      ELy[i] = ELy[i] + shift 
    } else {
      S = (l[ends(net.bg,i)[2],1] - l[ends(net.bg,i)[1],1]) / 
        (l[ends(net.bg,i)[1],2] - l[ends(net.bg,i)[2],2])
      shift = d / sqrt(1 + S^2)
      ELx[i] = ELx[i] + shift
      ELy[i] = ELy[i] + S*shift
    }
  }
 
  
  #highlight max interaction strength
  maxWeight <- max(UINT*100)
  E(net.bg)$color[E(net.bg)$width == maxWeight] <- 'red'
  E(net.bg)$color[E(net.bg)$width != maxWeight] <- 'gray70'
  
   
  # Threshold and Cluster option:
  if(Threshold == FALSE && Cluster == FALSE){
    p <- plot(net.bg, layout = l, vertex.label.family = "Helvetica", edge.label.family = "Helvetica",
              rescale = FALSE, xlim=range(l[,1]), ylim=range(l[,2]), 
              edge.label.x = ELx, edge.label.y = ELy)
    legend("topleft",bty = "n",
           legend = levels(Group),
           fill = pal, border = NA, title = "Importance Values")
    return(p) 
  }else if(Threshold == TRUE && Cluster == FALSE){
    a <- sort(UINT, decreasing  = TRUE)
    cut.off <- a[1:5]
    net.sp  <- delete_edges(net.bg, E(net.bg)[UINT<cut.off])
    pp <- plot(net.sp, layout = l, vertex.label.family = "Helvetica", edge.label.family = "Helvetica")
    legend("topleft",bty = "n",
           legend = levels(Group),
           fill = pal, border = NA, title = "Importance Values")
    return(pp)
  }else if(Threshold == FALSE && Cluster == TRUE){
    clp <- cluster_optimal(net.bg)
    ppp <- plot(clp, net.bg, vertex.label.family = "Helvetica", edge.label.family = "Helvetica")
    legend("topleft",bty = "n",
           legend = levels(Group),
           fill = pal, border = NA, title = "Importance Values")
    return(ppp)
  }else if(Threshold == TRUE && Cluster == TRUE){
    a <- sort(UINT, decreasing  = TRUE)
    cut.off <- a[1:5]
    net.sp  <- delete_edges(net.bg, E(net.bg)[UINT<cut.off])
    clp <- cluster_optimal(net.sp)
    pppp <- plot(clp, net.sp, vertex.label.family = "Helvetica", edge.label.family = "Helvetica")
    legend("topleft",bty = "n",
           legend = levels(Group),
           fill = pal, border = NA, title = "Importance Values")
    return(pppp)
    }
}
```

Example with Treshold = FALSE, Cluster = FALSE, edge.label = FALSE
```{r}
importanceNet(irClasTask, irMod, method = "randomForest")
```

Example with Treshold = FALSE, Cluster = FALSE, edge.label = TRUE
```{r}
importanceNet(irClasTask, irMod, method = "randomForest", edge.label = TRUE)
```

Example with Threshold = TRUE and Cluster = FALSE
```{r, warning = FALSE}
importanceNet(irClasTask, irMod, method = "ranger Permutation", Threshold = TRUE, Cluster = FALSE)
```

Example with Threshole = TRUE and Cluster = TRUE
```{r, warning = FALSE}
importanceNet(irClasTask, irMod, method = "rfSRC Importance", Threshold = TRUE, Cluster = TRUE)
```

## Partial Dependence Plots


__Description__

Plots the partial dependence for each pair of variables, utalizing an Eularian tour to dsiplay the plots

__Usage__

INSERT USAGE

__Arguments__

INSERT ARGUMENTS

__Value__

INSERT VALUE

__Examples__

INSERT EXAMPLE
