---
title: "Variable Importance and Variable Interaction Displays (vivid)"
author: "Alan Inglis, Catherine Hurley, Andrew Parnell"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Details:
__Type__ Package

__Title__ vivid

__Version__ 0.1.0

__Description__ A package for displaying variable importance and two-way variable interaction on the same plot. Partial dependence plots are also available in this package.

__Licence__ GPL (>=2)

__Depends__

__Imports__

__Authors__ Alan n. Inglis, Catherine Hurley, Andrew Parnell

## Introduction
This package was designed to help a user to easily distinguish which variables in a model are important and which variables interact with each other. It does this by giving the user different plotting options. These include a heatmap style plot that displays 2-way interactions and individual variable importance. Also, a network style plot where the size of a node represents variable importance (the bigger the node, the more important the variable) and the edge weight represents the 2-way interaction strength. Also included is an option to display partial dependence plots that utilize an Eularian tour to help the user to easily identify which variables interact the most.
The interaction is calculated using *Friedman's H-Statistic*^[H. Friedman and B.E. Popescu. Predictive learning via rule ensemble. The Annals of Applied Statistics,, pages 916–954, 2008.].


```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Load nessecery packages:
library(dplyr)
library(mlr)
library(reshape2)
library(ggplot2)
library(iml)
library(tidyr)
library(igraph)
library(plotly)
library(ggnewscale)
library(RColorBrewer)
library(GGally)
```

## Data used in this vignette:

The data used in the following examples is the *air quality* data which is the daily air quality measurements in New York, May to September 1973^[Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983) Graphical Methods for Data Analysis. Belmont, CA: Wadsworth.]. 
The data contains 6 variables which are described as follows:

* Ozone: Mean ozone in parts per billion from 1300 to 1500 hours at Roosevelt Island.

* Solar.R: Solar radiation in Langleys in the frequency band 4000–7700 Angstroms from 0800 to 1200 hours at Central Park.

* Wind: Average wind speed in miles per hour at 0700 and 1000 hours at LaGuardia Airport.

* Temp: Maximum daily temperature in degrees Fahrenheit at La Guardia Airport.

* Month: The month the data was recorded (takes a value between 1-12).

* Day: The day the the data was recorded (takes a value between 1-7).

In all the following examples, *Ozone* is used as the response variable. 


## Commands:

# intHeatmap()
___
*Create a Heatmap style plot displaying Variable Importance and Variable Interaction*

___

__Description__

Plots a heatmap of the interaction strength with variable importance on the off-diagonal

__Usage__

intHeatmap(task, model, method, interact)

__Arguments__

* task - Task created from the ```mlr``` package (either regression or classification).

* model - Any machine learning model.

* method - A list of variable importance methods to be set by the user. These can include any of the importance methods contained within the ```mlr``` package. The default is method = randomForest.
 
* interact - If interact = TRUE, an interactive plotly object is displayed where the user can hover the mouse icon over any part of the plot and a text box will appear displaying information related to the selected variables. 
 

__Examples__

```{r}
# Get data ----------------------------------------------------------------
## Air quality data (used for regression)

aq <- data.frame(airquality)
aq <- na.omit(aq)

# mlr set up --------------------------------------------------------------

aqRgrTask  <- makeRegrTask(data = aq, target = "Ozone")
aq.regr.lrn <- makeLearner("regr.randomForest")
aqMod <- train(aq.regr.lrn, aqRgrTask)

```

```{r, echo = FALSE}
## Heatmap Plotting Function -------------------------------------------------------

intHeatmap <- function(task, model, method = "randomForest",
                       interact = FALSE,...){
  # get data:
  data <- getTaskData(task)
  # Get Importance Measures -------------------------------------------------
  
  norm.task <- normalizeFeatures(task, method = "standardize")
  
  im_feat <- generateFilterValuesData(norm.task, method = method)
  Y_Imp <- im_feat$data$value



  mod  <- Predictor$new(model, data)
  res  <- NULL
  ovars <- getTaskFeatureNames(task)
  for (i in 1:length(ovars))
    res <- rbind(res, Interaction$new(mod, feature=ovars[i])$results)
  
  res[[".feature"]] <- reorder(res[[".feature"]], res[[".interaction"]])
  
  vars2 <- t(simplify2array(strsplit(as.character(res[[".feature"]]),":"))) # split/get feature names 
  dinteraction <- matrix(0, length(ovars), length(ovars))                   # create matrix
  rownames(dinteraction) <- colnames(dinteraction) <- ovars                 # set names
  dinteraction[vars2] <- res[[".interaction"]]                              # set values   
  dinteraction <- (dinteraction+t(dinteraction))/2                          # avg over values to make symmetrical
  diag(dinteraction) <- Y_Imp
  
  nam <- getTaskFeatureNames(task)
# Now create a plot -------------------------------------------------------

  var_int2 = dinteraction %>% as_tibble %>% 
    mutate(var_num1 = 1:length(nam)) %>% 
    pivot_longer(cols = 1:length(nam),
                 values_to = 'Interaction\nStrength') %>% 
    mutate(var_num2 = rep(1:length(nam), length(nam)),
           alpha_imp = as.integer(var_num1 == var_num2),
           alpha_int = 1 - alpha_imp,
           `Variable\nImportance` = alpha_imp*`Interaction\nStrength`,
           `Interaction\nStrength` = alpha_int*`Interaction\nStrength`)

  
  

  # for plotly  -------------------------------------------------------------
  dinteraction1 <- data.frame(interaction=as.vector(dinteraction))          # Create df
  
  dinteraction1$x <- as.vector(row(dinteraction))
  dinteraction1$y <- as.vector(col(dinteraction))
  dinteraction1$varx <- ovars[dinteraction1$x]
  dinteraction1$vary <- ovars[dinteraction1$y]
  dinteraction1$varx <- factor(dinteraction1$varx, levels=ovars)
  dinteraction1$vary <- factor(dinteraction1$vary, levels=rev(ovars))      
  
  # Importance point size:
  if(length(Y_Imp) <= 5)
  {pointSize = 15
  } else if(length(Y_Imp) <= 10)
  {pointSize = 10
  }else if(length(Y_Imp <= 15))
  {pointSize = 7}
  
  labTitle = method
  
  impMat <- matrix(0,nrow=length(Y_Imp), ncol=length(Y_Imp))
  diag(impMat) <- Y_Imp
  importMatrix <- melt(impMat)
  
  p <- ggplot(data = var_int2, 
         mapping = aes(x = var_num1, y = var_num2)) + 
    scale_x_continuous(breaks = 1:length(nam), labels = nam, position = "top") + 
    scale_y_reverse(breaks = 1:length(nam), labels = nam) +
    geom_raster(aes(fill = `Interaction\nStrength`),
                alpha = var_int2$alpha_int) + 
    new_scale_fill() +
    geom_raster(aes(fill = `Variable\nImportance`),
                alpha = var_int2$alpha_imp) + 
    scale_fill_gradient(low = "red4",high = "red") +
    ggtitle(labTitle) +
    xlab('') + 
    ylab('') + 
    theme_light() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
  
  # This plot is only called for plotly as newGeom_raster is not supported
  Importance <- Y_Imp
  pp <- ggplot(data=dinteraction1, aes(x=varx,y=vary)) + 
    geom_tile(aes(fill = interaction), dinteraction1 %>% filter(dinteraction1$varx != dinteraction1$vary)) +
    geom_point(aes(x=Var1,y= rev(Var2),colour = Importance),size = pointSize, importMatrix %>% filter(importMatrix$Var1==importMatrix$Var2)) +
    scale_colour_gradient(low="red4", high="red") +
    labs(colour= labTitle) +
    labs(fill='Interaction \n\ Strength') +
    theme(axis.title.x=element_blank(),axis.title.y=element_blank()) +
    scale_x_discrete(position = "top") + theme_bw()+
    xlab("")+ylab("")
  
  
  # Interactive plot using plotly
  ppp <- ggplotly(pp, tooltip = "all")

  if(interact == TRUE){
    return(ppp)
  }else{return(p)}
}
```

To call the plot we use the ```intHeatmap()``` command as follows: 

```{r, fig.width = 8, fig.height = 6}
# Plot Heatmap
intHeatmap(aqRgrTask, aqMod, method = "randomForest_importance", interact = F)
```
<center>
Fig 1.0: *Heatmap style plot displaying 2-way interaction strength in blue and individual variable importance on the diagonal in red.*
</center>

From the above plot, the user can easily see that *Temp* is the most important variable when preidicting *Ozone*. Also, there is a clear and strong interaction between *Month* and *Day*. 



# importanceNet():

___
*Create a Network style plot displaying Variable Importance and Variable Interaction*

___

__Description__

Plots a network style graph, where node size represents variable importance and edge width and colour represents interaction strength. The edge colour is displayed as a gradient from black to red. Black represents a weak interaction, whereas red displayes stronger interactions.

__Usage__

importanceNet(task, model, method, Threshold, ThresholdValue, Cluster)

__Arguments__

* task - Task created from the ```mlr``` package (either regression or classification).

* model - Any machine learning model.

* method - A list of variable importance methods to be set by the user. These can include any of the importance methods contained within the ```mlr``` package. The default is method = randomForest.
 
* Threhold - If Threshold = TRUE then only the strongest interactions are displayed. 

* ThresholdValue - This values detremines the amount of edges to display.

* Cluster - If Cluster = TRUE then the data is clustered according to interactions.  

__Examples__



```{r, echo = FALSE}
importanceNet <- function(task, model, method = "randomForest_importance",Threshold = F, 
                                      ThresholdValue = 0,Cluster = F,...){
  
  
  # get data:
  data <- getTaskData(task)
  
  # Get importance values:
  
  norm.task <- normalizeFeatures(task, method = "standardize")
  im_feat <- generateFilterValuesData(norm.task, method = method)
  Imp<- im_feat$data$value
  Imp<- (100)*(Imp-min(Imp))/(max(Imp)-min(Imp))  # Scale the Importance between 10-50 
  
  Mod <- Predictor$new(model, data = data) # iml Interaction Strength
  
  # Get names and interaction strength:
  res <- NULL
  ovars <- getTaskFeatureNames(task)
  for (i in 1:length(ovars))
    res <- rbind(res, Interaction$new(Mod, feature=ovars[i])$results)
  
  res[[".feature"]]<- reorder(res[[".feature"]], res[[".interaction"]])
  
  vars2 <- t(simplify2array(strsplit(as.character(res[[".feature"]]),":"))) # split/get feature names 
  dinteraction <- matrix(0, length(ovars), length(ovars))                   # create matrix
  rownames(dinteraction) <- colnames(dinteraction) <- ovars                 # set names
  dinteraction[vars2] <- res[[".interaction"]]                              # set values   
  dinteraction <- (dinteraction+t(dinteraction))/2                          # avg over values to make symmetrical
  
  dinteraction1 <- data.frame(interaction=as.vector(dinteraction))   
  
  SortInt = t(dinteraction)[lower.tri(t(dinteraction), diag=FALSE)]  # get upper triangle of the matrix by row order
  Sorted_Int <- sort(SortInt, index.return=TRUE)   # Sort values whilst preserving the index 
  InteractionValues <- Sorted_Int$x
  nam <- getTaskFeatureNames(task) # Get feature names 
  
  # setting var names:
  INT <- InteractionValues
  
  # Set path direction of graph:
  g <- sample_pa(length(nam), m = length(nam))
  df <- igraph::as_data_frame(g)
  gDF <- dplyr::arrange(df, to)
  gDFL <- rbind(gDF$from,gDF$to)
  matched_gDFL <- gDFL[,Sorted_Int$ix]
  
  # Create network graph:
  net.bg <- make_graph(matched_gDFL, length(nam)) 

  # Scale and round values:
  UintScaled <- INT*10
  Rint <- round(UintScaled, 2)
  Imp <- round(Imp,2)
  E(net.bg)$weight <- Rint
  
  # Set colour palette: 
  colfunc <- colorRampPalette(c("black", "red"))
  
 # Plotting function:
  if(Threshold == FALSE && Cluster == FALSE){
    p <- ggnet2(net.bg, mode = "circle", 
              size = Imp,
              node.color = "grey80",
              label = nam,
              edge.size = Rint,
              edge.label = Rint,
             edge.color = colfunc(length(Rint)))+
       theme(legend.text = element_text(size = 0))
    return(p) 
     }else if(Threshold == TRUE && Cluster == FALSE){
       a <- sort(Rint, decreasing  = TRUE)
       cut.off <- a[1:5]
       `%notin%` <- Negate(`%in%`)
       net.sp  <- delete_edges(net.bg, E(net.bg)[E(net.bg)$weight %notin% cut.off])
       weightDF <- get.data.frame(net.sp) # get df of graph attributes
       EdgeWidth1 <- weightDF$weight  # select edge weight
       pp <- ggnet2(net.sp, mode = "circle",
                   size = Imp,
                   color = "grey80",
                   label = nam,
                   edge.size = EdgeWidth1,
                   edge.label = EdgeWidth1,
                   edge.color = colfunc(length(EdgeWidth1)))+
         theme(legend.text = element_text(size = 0))
       return(pp)}
     # }else if(Threshold == FALSE && Cluster == TRUE){
     #   V(net.bg)$label <- nam
     #   E(net.bg)$width <- Rint
     #   E(net.bg)$arrow.mode <- 0
     #   E(net.bg)$label <- round(UINT, 2)
     #   E(net.bg)$label.cex <- 1
     #   clp <- cluster_optimal(net.bg)
     #   ppp <- plot(clp, net.bg, vertex.label.family = "Helvetica", edge.label.family = "Helvetica")
       # ppp <- ggnet2(clp, mode = "circle",
       #              size = Imp,
       #              color = "grey50",
       #              node.color = "grey50",
       #              label = nam)+
                   # edge.size = Rint)+
                   # theme(legend.text = element_text(size = 0))
                   # edge.label = Rint)
                   # edge.color = colfunc(length(Rint)))
     #   return(ppp)
     # }else if(Threshold == TRUE && Cluster == TRUE){
     #   V(net.bg)$label <- nam
     #   E(net.bg)$width <- Rint
     #   E(net.bg)$arrow.mode <- 0
     #   a <- sort(UINT, decreasing  = TRUE)
     #   cut.off <- a[1:5]
     #   net.sp  <- delete_edges(net.bg, E(net.bg)[UINT<cut.off])
     #   clp <- cluster_optimal(net.sp)
     #   pppp <- plot(clp, net.sp, vertex.label.family = "Helvetica", edge.label.family = "Helvetica")}
}
```

To call the plot we use the ```imprtanceNet()``` command as follows:

```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
importanceNet(aqRgrTask, aqMod, method = "randomForest_importance", Threshold = F, Cluster = F)
```
<center>
Fig 2.0: *Network style plot displaying 2-way interaction strength between each of the variables and individual variable importance*
</center>

The edge width, in the above plot, indicates the interaction strength, with the actual value displayed in the centre of of the edges. The colour of the edges also visually represents the interaction strength through use a of colour gradient, with low values being in black and high values being in red. 

The node size represents individual varialbe importance with respect to predicting the response. 

As can be seen in the above plot, *Month* and *Day* have the largest interaction and *Temp* is the most important variable for predicting *Ozone*. 

If ```Threshold = TRUE``` then only the strongest interactions are displayed. The amount of edges can be decided by the user using the ```ThresholdValue``` argument. In the following example, ```ThresholdValue = 3``` means that only the top 3 strongest interactions are displayed.:


```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
importanceNet(aqRgrTask, aqMod, method = "randomForest_importance", Threshold = T, 
                                ThresholdValue = 3, Cluster = F)
```
<center>
Fig 2.1: *Network style plot displaying thresholded 2-way interaction strengths between each of the variables and individual variable importance. In this plot the top 3 strongest interactions are displayed*
</center>

# PDPpairs():

___
*Creates a plot of the partial dependence of each of the variables in pairs plot style matrix*

___


```{r, fig.width = 8, fig.height = 7, echo = FALSE}

aqRgrTask  <- makeRegrTask(data = aq, target = "Ozone")
aq.regr.lrn <- makeLearner("regr.randomForest", id = 'rf')
aqMod <- train(aq.regr.lrn, aqRgrTask)





pred.aq <- Predictor$new(aqMod, data = aq)

colorfn <- function(vec, cols= NULL, expand=.07){
  if (is.null(cols))
    cols <-  brewer.pal(8, "Blues")
  
  r <- range(vec, na.rm = TRUE)
  if (diff(r) == 0){
    r <- c(r[1]-.5, r[1]+.5)
  }
  else {
    fudge <- diff(r)*expand
    r[1] <- r[1]- fudge
    r[2] <- r[2]+ fudge
    r <- seq(r[1], r[2],length.out=length(cols)+1)
  }
  
  fn <- function(x){
    index <- as.numeric(cut(x,breaks=r, include.lowest=TRUE))
    
    cols[index]
  }
  structure(fn,breaks=r)
}


legendn <- function(colorY){
  
  
  r <- attr(colorY, "breaks")
  z1<- r[-length(r)]
  z2<- r[-1]
  rectcols <- colorY(r[-1])
  
  
  plot( c(0,1),c(z1[1], z2[length(z2)]),  ann=FALSE, axes=F, type="n")
  
  rect(0,z1,1,z2,col=rectcols, lty=0)
  par(mgp = c(2, 0.2, 0))
  axis(2,cex.axis=.7, lwd=0, lwd.ticks=.5 )
}

colfn <- colorfn(aq$Ozone)



pdpPairs <- pairs(aq[,2:6], panel = function(x,y) {
  xvar <- names(which(sapply(aq, function(u) identical(u, x))))
  yvar <- names(which(sapply(aq, function(u) identical(u, y))))
  pdp <-FeatureEffect$new(pred.aq, c(xvar,yvar), method = "pdp", grid.size=10)
  g <- pdp$results
  dx <- g[2,1] - g[1,1]
  dy <- g[11,2] - g[1,2]
  g$left <- g[,1] - dx/2
  g$right <- g[,1] + dx/2
  g$bottom <- g[,2] - dy/2
  g$top <- g[,2] + dy/2
  
  g$cols <- colfn(g[,3])
  rect(g$left, g$bottom, g$right, g$top, col=g$cols, border=NA)
})


# par(mar=c(2,2,2,2))
# legendn(colfn)
```
<center>
Fig 3.0: *A pairs style matrix plot displaying the partial dependence between each of the variables*
</center>





