---
title: "Variable Importance and Variable Interaction Displays (vivid)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vivid}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 7
)
```

```{r setup, message=FALSE, echo = FALSE}
library(vivid)
```

## Introduction

This package was designed to help a user to easily distinguish which
variables in a model are important and which variables interact with
each other. It does this by giving the user different plotting options.
These include a heat-map style plot that displays 2-way interactions and
individual variable importance. Also, a network style plot where the
size of a node represents variable importance (the bigger the node, the
more important the variable) and the edge weight represents the 2-way
interaction strength.  The interaction is
calculated using *Friedman’s H-Statistic*^[Friedman, H. and Popescu, B.E. Predictive learning via rule ensemble. The Annals of Applied Statistics. 2008. 916-954]

## Data used in this vignette:

The data used in the following examples is the *abalone* data from the `AppliedPredictiveModeling` package^[AppliedPredictiveModeling: Functions and Data Sets for 'Applied Predictive Modeling'. M. Kuhn and K. Johnson. 2018. https://CRAN.R-project.org/package=AppliedPredictiveModeling] which contains measurements obtained from 4177 abalones. The data contains measurements of the type (male, female and infant), the longest shell measurement, the diameter, height and whole, shucked, viscera and shell weights. The response variable is rings. The age of the abalone can be determined by counting the rings plus 1.5.
The variables are described as follows:

  - Rings: +1.5 gives the age in years.

  - Longest shell: Longest shell measurement (mm).

  - Diameter: Perpendicular to length (mm).

  - Height: With meat in shell (mm).

  - Whole weight: Whole abalone (gm).

  - Shucked weight: Weight of meat (gm).
  
  - Viscera weight: Gut weight (after bleeding) (gm).
  
  - Shell weight: After being dried (gm).

In all the following examples, a subset of the data is used and *Rings* is used as the response variable.

## Commands:

## `prepFunc()`

-----

* This function creates a matrix creates a symmetrical matrix filled with pair-wise interaction strengths and varible importance on the diagonal. 

-----

**Description**

Uses Friedman's H-Statistic to calculate the pair-wise interaction strength and uses embedded feature selection methods to determine the variable importance. If the supplied learner does not support an embedded variable importance measure, an agnostic approach will be applied to genereate the importance values. This function takes in any task and model created from the `mlr` package and results in a matrix which can be supplied to the plotting functions in the `vivid` package. However, if the user wishes, they can supply their own matrix to plot. The `parallel` argument (default is FALSE) allows the user to run the interaction calculation in parallel.

**Usage**

prepFunc(task, model, remove, percentRemove, parallel)

**Example**

Load in the data:
```{r, messages = FALSE}
library(AppliedPredictiveModeling)
data(abalone)
ab <- data.frame(abalone)
ab <- na.omit(ab)
ab <- ab[1:500,]
```

Run an `mlr3` ranger model:

```{r}
library(mlr3)
library(mlr3learners)
ab_task  <- TaskRegr$new(id = "abalone", backend = ab, target = "Rings")
ab_lrn <- lrn("regr.ranger", importance = "permutation")
ab_mod <- ab_lrn$train(ab_task)
```

Create a matrix to be supplied to the plotting functions.

```{r}
myMatrix <- prepFunc(task = ab_task, learner = ab_lrn, model = ab_mod, remove = FALSE, 
                     percentRemove = 0.5, parallel = F)
```


## `plotHeatMap()`

-----

*Create a Heat-map style plot displaying Variable Importance and Variable
Interaction*

-----

**Description**

Plots a heat-map of the interaction strength with variable importance on
the off-diagonal

**Usage**

plotHeatMap(mat, plotly, intLow, intHigh, impLow, impHigh, top, reorder)


**Example**

To call the plot we use the `plotHeatMap()` command as follows:

```{r, fig.width = 9, fig.height = 7}
set.seed(1701)
plotHeatMap(mat = myMatrix,  plotly = F,
          intLow = "floralwhite", intHigh = "dodgerblue4",
          impLow = "white", impHigh = "firebrick1")
```
<center>
Fig 1.0: *Heat-map style plot displaying 2-way interaction strength in blue and individual variable importance on the diagonal in red.*
</center>

From the above plot we can see that `LongestShell:VisceraWeight` weight has the strongest interaction and `ShellWeight` is the most important variable for predicting `rings`.

## `plotNetwork()`

-----

*Create a Network style plot displaying Variable Importance and Variable 
Interaction*

-----

**Description**

Plots a network style graph, where node size represents variable importance and edge width and colour represents interaction strength. The edge colour is displayed as a gradient from black to red. Black represents a weak interaction, whereas red displays stronger interactions.

**Usage**

plotNetwork(mat, thresholdValue = 0,
                          label = FALSE, minInt = 0, maxInt = NULL, minImp = 0, maxImp = NULL,
                          labelNudge = 0.05, layout = "circle",
                          cluster = F,...)
                          
**Example**

To call the plot we use the `plotNetwork()` command as follows:

```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
plotNetwork(mat = myMatrix, thresholdValue = 0, 
              minInt = 0, maxInt = 1, 
              minImp = 0, maxImp = 100,
              labelNudge = 0.05)
```
<center>
Fig 2.0: *Network style plot displaying 2-way interaction strength between each of the variables and individual variable importance*
</center>

The edge width, in the above plot, indicates the interaction strength, with the actual value displayed in the centre of of the edges. The colour of the edges also visually represents the interaction strength through use a of colour gradient, with low values being in black and high values being in red. 

The node size represents individual variable importance with respect to predicting the response. 

From the above plot we can see that `LongestShell:VisceraWeight` weight has the strongest interaction and `ShellWeight` is the most important variable for predicting `rings`.

The user can control which interaction values to display by using the `thresholdValue` argument. In the following example, `thresholdValue = 0.11` means that only the the edges with weights (i.e., the interactions) above 0.09 are displayed:

```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
plotNetwork(mat = myMatrix, thresholdValue = 0.11, cluster = F)
```
<center>
Fig 2.1: *Network style plot displaying thresholded 2-way interaction strengths between each of the variables and individual variable importance. In this plot only the interactions greater than 0.11 are shown.*
</center>



## `ggpdpPairs()`

-----

*Creates a  pairs plot style matrix plot of the 2D partial dependence of each of the variables in the upper diagonal, the individual pdp and ice curves on the diagonal and a scatter-plot of the data on the lower diagonal*

-----

*Description*

Plots a pdp (partial dependence plot) pairs style matrix. The partial dependence plot shows the marginal effect one or two features have on the predicted outcome of a machine learning model^[Friedman, Jerome H. “Greedy function approximation: A gradient boosting machine.” Annals of statistics (2001): 1189-1232.]. A partial dependence plot is used to show whether the relationship between the response variable and a feature is linear or more complex.

**Usage**

ggpdpPairs(task, model, method="pdp", corrVal = FALSE, corr = FALSE, corrMethod = "p",
                       parallel = FALSE, vars=NULL, colLow = "#132B43", colHigh = "#56B1F7",
                       fitlims = NULL,gridsize = 10,class=1,cardinality = 20)

**Example**

Load in the data:
```{r, messages = FALSE}
library(AppliedPredictiveModeling)
data(abalone)
ab <- data.frame(abalone)
ab <- na.omit(ab)
ab <- ab[1:500,]
```

Run an `mlr3` ranger model:
```{r}
library(mlr3)
library(mlr3learners)
ab_task  <- TaskRegr$new(id = "abalone", backend = ab, target = "Rings")
ab_lrn <- lrn("regr.ranger", importance = "permutation")
ab_mod <- ab_lrn$train(ab_task)
```

To call the pdp pairs plot we use:
```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
ggpdpPairs(task = ab_task, model =  ab_mod)
```
<center>
Fig 3.0: *A pairs style matrix plot displaying the partial dependence between each of the variables in the upper diagonal, the individual pdp and ice curves on the diagonal and a scatter-plot on the lower diagonal*
</center>

From the above plot, we see the 2D pdp plots on the upper diagonal. The individual pdp and ice cures on the diagonal and scatter-plots on the lower diagonal. As `type` is a factor variable with 3 levels, a barplot displaying the frequency is displayed on the diagonal and the individual pdp curves are shown on the upper diagonal for this variable. 



In addition to displaying both the variable importance and interactions together, the `vivid` package also allows to display only the variable importance _or_ the interaction strength via the folowing functions. 

## `allInt()`

-----

*Creates a plot, displaying the interaction strength for all the 2-way interactions in a model*

-----

*Description*
Plot displaying the 2-way interactions on the y-axis and the interaction strength on the x-axis. This function also allows the user to switch between a lollipop style plot (which is default) and a barplot, by use of the `type` argument. 

**Usage**

allInt(mat, type = "lollipop", top = 0)


To call the pdp pairs plot we use:
```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
allInt(mat = myMatrix, top = 0)
```
<center>
Fig 4.0: *A plot displaying all 2-way interaction in a model.*
</center>

From the above plot we can see that `LongestShell:VisceraWeight` has the strongest interaction.

## `interactionPlot()`

-----

*Creates a plot, displaying the overall interaction strength for each variable in a model*

-----

*Description*
Plot displaying the variables on the y-axis and the overall interaction strength on the x-axis. This function also allows the user to switch between a lollipop style plot (which is default) and a barplot, by use of the `type` argument. 

**Usage**

interactionPlot(task, model, type)

**Example**

Load in the data:
```{r, messages = FALSE}
library(AppliedPredictiveModeling)
data(abalone)
ab <- data.frame(abalone)
ab <- na.omit(ab)
ab <- ab[1:500,]
```

Run an `mlr3` ranger model:
```{r}
library(mlr3)
library(mlr3learners)
ab_task  <- TaskRegr$new(id = "abalone", backend = ab, target = "Rings")
ab_lrn <- lrn("regr.ranger", importance = "permutation")
ab_mod <- ab_lrn$train(ab_task)
```

To call the interaction plot we use:
```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
interactionPlot(task = ab_task, model =  ab_mod, type = "barplot")
```
<center>
Fig 5.0: *A plot displaying the overall interaction strength for each variable in a model.*
</center>

From the above plot we can see that the variable with the strongest overall interaction strength is `ShellWeight`

## `importancePlot()`

-----

*Creates a plot, displaying the variable importance for each variable in a model*

-----

*Description*
Plots variables on the y-axis and the variable importance on the x-axis. This function also allows the user to switch between a lollipop style plot (which is default) and a barplot, by use of the `type` argument. 

**Usage**

importancePlot(mat, type = "lollipop")

**Example**

To call the pdp pairs plot we use:
```{r, fig.width = 8, fig.height = 7}
set.seed(1701)
importancePlot(mat = myMatrix, type = "barplot")
```
<center>
Fig 6.0: *A plot displaying the variable importance for each variable in a model.*
</center>

From the above plot, we can see that the most important variable, when prediciting `rings` is `ShuckedWeight`


## `genFriedman()`

-----

*Simulates data from the Friedman benchmark problem 1*

-----

*Description*

Simulate data from the Friedman benchmark problem 1^[Friedman, Jerome H. (1991) Multivariate adaptive regression splines. The Annals of Statistics 19 (1), pages 1-67.]. The output is created according to the formula:


<center>
$$y = 10 sin(π x1 x2) + 20 (x3 - 0.5)^2 + 10 x4 + 5 x5 + e$$
</center>


By default the number of features is set to 10 and the number of samples is set to 100. `sigma` denotes the standard deviation of the noise. `bins` denotes the number of bins to split responce variable into. Setting a value greater than 1 turns this into a classification problem where bins determines the number of classes. If the `seed` argument is not NULL, then the random seed will be set as using the function each time will produce different results. 

**Usage**

genFriedman(noFeatures = 10, noSamples = 100, sigma = 1, bins = NULL, seed = NULL)

**Example**

To call the pdp pairs plot we use:
```{r}
myData <- genFriedman(noFeatures = 10, noSamples = 100, sigma = 1, bins = NULL, seed = NULL)
head(myData)
```


